---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
#install.packages("DBI")
#install.packages("RMySQL")
#install.packages("knitr") 
#install.packages("progress")

library(knitr) 
suppressWarnings({
  library(DBI)
  library(RMySQL)
  library(ggpval)
  library(openxlsx)
  library(ggplot2)
  library(EnvStats)
  library(ggpubr)
  library(psych)
  library(stringr)
  library(plotrix)
  library(BSDA)
  library(dplyr)
  library(readr)
  library(ggplate)
  library(ggrepel)
  library(tidyr)
  library(data.table)
  library(progress)

})


```

```{r}
#---------------------------------------------------------------------------------------------
#MUST PERSONALIZE THIS CODE BLOCK
#change every run

#Enter the plate number being analyzed
#plate_num <- "3"

# What Foci are you analyzing?
foci_Type <- "MLF2-GFP Foci"
  
# What is your positive control?
# pos_Ctrl1 <- "Nup98"
# pos_Ctrl2 <- "PLK1"

pos_Ctrl <- "Tor1A_1B"


# What is your negative control?
neg_Ctrl <- "NT sgRNAs"

#Enter file path location of where you saved the Cell Profiler XLSX data sheets:
#This is also where any output will be saved
#file_Location <- "D:/CRISPR_Screen_Analysis_dp/WT_Screen/"

file_Location <- "/Users/dylan/Documents/papers_grants_other/SmallMoleculeNuclearCondensates/data/"
#/Desktop/New_Data_AFTER_23_11_17/Dylan_new/NE_Bleb_CRISPR_Screens/TorKO_CRISPR_screen/datasheets/"
#KOScreen_test_650_661_668_677Cyto.csv
#OPTIONAL
#If you have different timepoints:
#timept <- "24h"

#---------------------------------------------------------------------------------------------
```

```{r}
#defines additional file and save locations based on above path input
trial_Name <- paste("Plate", sep = " ")

#file_Path <- paste(file_Location, "plate", plate_num, "_trial2/", sep = "")
#OR if you have multiple timepoints (OPTIONAL):
#file_Path <- paste(file_Location, "plate", plate_num, "_", "_trial2/", sep = "")

image_Save_Location <- "/Users/dylan/Documents/papers_grants_other/SmallMoleculeNuclearCondensates/data/"

save_Location <- paste(image_Save_Location, "WT_CRISPR_finalAnalysis.xlsx", sep = "")
#saveWorkbook(wb, save_Location, overwrite = TRUE)

```

```{r}
#Make a list to iterate and extract all the different analysis run. Then put the following in a loop.
path_Files <- "/Users/dylan/Documents/papers_grants_other/SmallMoleculeNuclearCondensates/data/"
list_Plate_Runs <- list.files(path_Files)

image_Set_List <- c()
foci_Set_List <- c()
  
for (i in 1:length(list_Plate_Runs)){
  
  if (str_detect(list_Plate_Runs[i], 'Image') == TRUE){
    image_Set_List <- c(image_Set_List, list_Plate_Runs[i]) 
  }

  if (str_detect(list_Plate_Runs[i], 'Cyto') == TRUE){
    foci_Set_List <- c(foci_Set_List, list_Plate_Runs[i]) 
  }

}

```




```{r}
# Define the total number of iterations

# Function to generate a textual progress bar
generate_progress_bar <- function(progress, width = 20) {
  completed <- round(progress / 100 * width)
  bar <- paste(rep("=", completed), collapse = "")
  empty <- paste(rep(" ", width - completed), collapse = "")
  return(sprintf("[%s%s] %.2f%%", bar, empty, progress))
}


for (i in 1:length(image_Set_List)){

  # Generate progress bar
  progress <- i / length(image_Set_List) * 100
  progress_bar <- generate_progress_bar(progress)
  # Print progress percentage and progress bar
  cat(sprintf("\rProgress: %s", progress_bar))
  flush.console()  # Flush the console to make sure the message is printed immediately
  
  suppressMessages({
  suppressWarnings({ 
    
  df1_MLF2 <- fread(paste0(file_Location, foci_Set_List[i]), select = 1:3)
#df <- read.csv(paste0(file_Location, foci_Set_List[4]))
  
  top_25 <- df1_MLF2 %>% 
group_by(ImageNumber) %>%
  arrange(ImageNumber, Children_MLF2_GFP_Count) %>%
  summarize(Children_MLF2_GFP_Count  = Children_MLF2_GFP_Count, ObjectNumber = ObjectNumber, nlen = ceiling(n() * 0.75))  

  
  top_25_filtered <- top_25 %>%
  group_by(ImageNumber) %>%
  filter(n() > 4) %>%  # Filter groups that have more than 4 rows
  filter(row_number() > nlen) %>%  # Then apply the filtering based on `nlen`
  ungroup()

top_25_filtered <- top_25_filtered[, c(1,3,2)]

  
  per_image_nuc <- df1_MLF2 %>%
  group_by(ImageNumber) %>%
  summarise(Nuclei_Number = n(), mean_Nuc_Foci = mean(Children_MLF2_GFP_Count))
  
  top_image_nuc <- top_25_filtered %>%
  group_by(ImageNumber) %>%
  summarise(Nuclei_Number_top = n(), mean_Nuc_Foci_top = mean(Children_MLF2_GFP_Count))
  
  MLF2_Area <-  fread(paste0(file_Location, image_Set_List[i]), select = c("AreaOccupied_AreaOccupied_MLF2_GFP", "AreaOccupied_AreaOccupied_Cyto", "Count_MLF2_GFP", "ImageNumber", "URL_GFP"))
  #MLF2_image <- MLF2_image[, c(2,1, 11, 37)]
  #MLF2_Area$URL_GFP <- MLF2_Area$URL_GFP
  MLF2_Area$Ratio_totalMLF2_vs_Cyto <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$AreaOccupied_AreaOccupied_Cyto)
  MLF2_Area$Avg_Size_Foci <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$Count_MLF2_GFP)

#For WT Cells:
  plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "_")
  Well_Num <- lapply(plate_Num_Temp, function(x)  x[length(x) - 2])
  Well_Num <- unlist(Well_Num)
  Image_Num <- lapply(plate_Num_Temp, function(x) x[length(x) - 1]) #10
  Image_Num <- unlist(Image_Num)
  plate_Num_Temp <- lapply(plate_Num_Temp, function(x) x[length(x) - 3]) #8
  plate_Num_Temp <- str_split(plate_Num_Temp, "-")
  plate_Num <- sapply(plate_Num_Temp, "[[", 3)
  plate_Num <- unlist(plate_Num)
  MLF2_Area$plate_Num <- plate_Num
  MLF2_Area$Well_Num <- Well_Num
  MLF2_Area$Imagecopy_Num <- Image_Num

  df <- (merge(per_image_nuc, MLF2_Area))
  #df <- bind_cols(df, top_image_nuc[, c(2:3)])
  df <- inner_join(df, top_image_nuc[,c("ImageNumber", "Nuclei_Number_top", "mean_Nuc_Foci_top") ], by = "ImageNumber")
  df$condition <- df$Well_Num
  #df <- na.omit(df)

  #Groups all wells that share a single condition for aggregate statistics
  per_Well_Plate <- df %>%
  group_by(plate_Num, Well_Num, condition) %>%
  #Filters out top image in case of screen aberration
  mutate(summary_condition = if_else(mean_Nuc_Foci > 1, mean_Nuc_Foci < max(mean_Nuc_Foci), TRUE)) %>%
  filter(summary_condition) %>%
  summarise(Nuclei_Number = mean(Nuclei_Number), mean_Nuc_Foci = mean(mean_Nuc_Foci, na.rm = T), Ratio_totalMLF2_vs_Cyto = mean(Ratio_totalMLF2_vs_Cyto), Avg_Size_Foci = mean(Avg_Size_Foci), mean_NucNumberTop = mean(Nuclei_Number_top), mean_NucFociTop = mean(mean_Nuc_Foci_top))
  
#This would filter out lowest and highest image.
# filter(mean_Nuc_Foci < max(mean_Nuc_Foci)) %>%
# filter(mean_Nuc_Foci > min(mean_Nuc_Foci)) %>%

  individual_Plates <- split(per_Well_Plate, f = per_Well_Plate$plate_Num)

}) })


  #print(i)
  
 
   for (plate in 1:length(individual_Plates)){
     

            individual_Plates[[plate]] <- individual_Plates[[plate]] %>%
        
      mutate(condition = case_when(
          Well_Num %in% c("A01", "A02", "B01", "B02", "C01", "C02", "D01", "D02", "E01", "E02", "F01", "F02", "G01", "G02", "H01", "H02", "I01", "I02", "J01", "J02", "K01", "K02", "L01", "L02", "M01", "M02", "N01", "N02", "O01", "O02") ~  paste0(neg_Ctrl,  "_"),
    
          # Well_Num %in% c("A23", "B23", "C23", "D23", "E23", "F23", "G23", "H23", "I23", "J23", "K23", "L23", "M23", "N23", "O23") ~ paste0("Nup98",  "_"),
          # 
          # Well_Num %in% c("A24", "B24", "C24", "D24", "E24", "F24", "G24", "H24", "I24", "J24", "K24", "L24", "M24", "N24", "O24") ~ paste0("PLK1",  "_"),
          
              
          Well_Num %in% c("A23", "B23", "C23", "D23", "E23", "F23", "G23", "H23", "I23", "J23", "K23", "L23", "M23", "N23", "O23") ~ paste0("Tor1A_1B",  "_"),
          
          Well_Num %in% c("A24", "B24", "C24", "D24", "E24", "F24", "G24", "H24", "I24", "J24", "K24", "L24", "M24", "N24", "O24") ~ paste0("Remove",  "_"),
          
       # FALSE ~ NA_character_  # Add NA for unmatched cases
      ))
    
    }
  #---------------------------------------------------------------------------------------------
  
  for (plate in 1:length(individual_Plates)){
    
    individual_Plates[[plate]]$condition <- ifelse(is.na(individual_Plates[[plate]]$condition), individual_Plates[[plate]]$Well_Num, individual_Plates[[plate]]$condition)
  
  #Iterates over each plate to return the well location for its condition unless otherwise specified (e.g., a control)

    individual_Plates[[plate]] <- subset(individual_Plates[[plate]], !grepl("Remove_", condition))
    # individual_Plates[[plate]]$condition[individual_Plates[[plate]]$condition == "Remove_"] <- NA 
    # individual_Plates <- na.omit(individual_Plates)
    
    
    
    
    #This is a function to iterate the statistical analysis over each of the conditions per plate
    
    statistical_Analysis_compounds <- function(conditions){
    
      #Define the well location:
      #Only use if for confidentiality:
      # trial_Name_Cond <- unique(individual_Plates[[plate]]$Plate_Number)
      # well_Name <- unique(individual_Plates[[plate]]$Well_Num)
      trial_Name_Cond <- conditions$plate_Num
      well_Name <- conditions$Well_Num
      
      # mean_Nuc_Foci <- individual_Plates[[plate]]$mean_Nuc_Foci
      # mean_Cyto_Foci <- individual_Plates[[plate]]$mean_Cyto_Foci
      # well_Cell_Count <- individual_Plates[[plate]]$Nuclei_Number
      
      mean_Nuc_Foci <- conditions$mean_Nuc_Foci
      mean_NucFociTop <- conditions$mean_NucFociTop
      mean_NucNumberTop <- conditions$mean_NucNumberTop
      
      #mean_Cyto_Foci <- conditions$mean_Cyto_Foci
      well_Cell_Count <- conditions$Nuclei_Number
      mean_Ratio_MLF2 <- conditions$Ratio_totalMLF2_vs_Cyto   
      mean_Size_MLF2 <- conditions$Avg_Size_Foci
      
      #Signal to Background noise ratio (S/B) = mean(signal) / mean(background), where background = negative control:
      #We are looking for a S/B ratio > 5
      #MUST REVERSE THIS BACK TO NegCtrl/MeanNuclei for compound screen. But in WT CRISPR Screen we are trying to look at increasing foci so mean_Nuc_Foci/NegCtrl is appropriate.
      SB_Nuc_Foci <-  mean_Nuc_Foci / mean_Nuc_Foci_NegCtrl
    
      return(c(trial_Name_Cond, paste0(well_Name), mean_Nuc_Foci, well_Cell_Count, mean_Ratio_MLF2, mean_Size_MLF2, SB_Nuc_Foci, NA, NA, paste0(well_Name, "_", trial_Name), mean_NucFociTop, mean_NucNumberTop))
    
    }
    
    initial_file <- save_Location
    
  
    
    # Check if the file exists, if not create a new one
    if (!file.exists(initial_file)) {
      
      wb <- createWorkbook()
      
      addWorksheet(wb, "Combined Analysis")
      addWorksheet(wb, "Putative Actives")
      addWorksheet(wb, "Raw_Data")
      addWorksheet(wb, "Plate Statistics")
    
      starting_Int = 1 
      
      desired_columns <- c("Plate", "Well_Condition", "Average_foci_perCell", "Average_Cell_Count", "Avg_Ratio_MLF2", "Avg_Size_MLF2", "SB_Nuc_Foci", "Normalized_Effect", "Viability", "Well_and_Plate","mean_NucFociTop", "mean_NucNumberTop")
      empty_df <- data.frame(matrix(ncol = length(desired_columns), nrow = 1))
      colnames(empty_df) <- desired_columns
      

      
      plate_columns <- c("Plate", "Well_Condition", "Average_foci_perCell", "Average_Cell_Count", "Avg_Ratio_MLF2", "Avg_Size_MLF2", "SB_Nuc_Foci", "SD_Nuc_Foci", "Z_prime_Nuc_Foci", "CV_Nuc_Foci", "Normalized_Effect", "Viability", "Well_and_Plate", "mean_NucFociTop", "SD_NucFociTop")
      
      
      empty_df_plate <- data.frame(matrix(ncol = length(plate_columns), nrow = 1))
      colnames(empty_df_plate) <- plate_columns

      # If the file doesn't exist, create a data frame and save it
      writeData(wb, sheet = "Raw_Data", x = empty_df, startCol = 1, startRow = nrow(empty_df) + 1)
      writeData(wb, sheet = "Plate Statistics", x = empty_df_plate, startCol = 1, startRow = nrow(empty_df_plate) + 1)
      saveWorkbook(wb, save_Location, overwrite = T)
    
    }
 
    
    #Repeats essentially the same statistical analysis function but for all variables but includes the confidential nomenclature and skips the control specific calculations including Z' score and CV computation
    
    #Iterative approach for analyzing all negative control data and storing in a temporary dataframe specifically only for negative controls.
    columns_ <- c("Plate", "Well_Condition", "Average_foci_perCell", "Average_Cell_Count", "Avg_Ratio_MLF2", "Avg_Size_MLF2", "SB_Nuc_Foci", "Normalized_Effect", "Viability", "Well_and_Plate", "mean_NucFociTop", "mean_NucNumberTop")
    plate_columns <- c("Plate", "Well_Condition", "Average_foci_perCell", "Average_Cell_Count", "Avg_Ratio_MLF2", "Avg_Size_MLF2", "SB_Nuc_Foci", "SD_Nuc_Foci", "Z_prime_Nuc_Foci", "CV_Nuc_Foci", "Normalized_Effect", "Viability", "Well_and_Plate","mean_NucFociTop", "SD_NucFociTop")
    
    
   
      
    #----------------------------------------START HERE 
    stats_Df <- data.frame(matrix(nrow=1, ncol=length(columns_)))
    colnames(stats_Df) <- columns_
    
    empty_df_plate <- data.frame(matrix(nrow = 1, ncol = length(plate_columns)))
    colnames(empty_df_plate) <- plate_columns
  
    wb <- loadWorkbook(save_Location)
  
  
    #print(plate)
    #Creates temporary dataframe for per-plate calculations:
    temp_stats_Df <- data.frame(matrix(nrow=1, ncol=length(columns_)))
    colnames(temp_stats_Df) <-  columns_
    
    #Defines plate number
    trial_Name <- unique(individual_Plates[[plate]]$plate_Num)
    #print(trial_Name)
    addWorksheet(wb, paste0("Figures_", trial_Name))
  
    #Defines the individual worksheet for each plate that will have all visualizations per plate.
  
    #NEGATIVE CONTROL:
    #-------------------------------------------------
    #Statistics for the negative control:
    mean_Nuc_Foci_NegCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$mean_Nuc_Foci)
    sd_Nuc_Foci_NegCtrl <- sd(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$mean_Nuc_Foci)
    
    mean_Nuc_Foci_NegCtrl_Top <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$mean_NucFociTop)
    sd_Nuc_Foci_NegCtrl_Top <- sd(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$mean_NucFociTop)
    
    mean_Ratio_MLF2_NegCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$Ratio_totalMLF2_vs_Cyto)
    mean_Size_MLF2_NegCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$Avg_Size_Foci)
    
    
    #Coefficient of Variation (standard deviation / mean), lower = less variation across replicates. We are looking for CV < 15%
    #Most important for negative control, but might as well calculate for all wells.
    CV_Nuc_Foci_NegCtrl <- cv(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$mean_Nuc_Foci) * 100
  
      

    #Nuclei Count:
    mean_Cell_NegCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$Nuclei_Number)
    #sd_Cell_NegCtrl <- sd(filter(individual_Plates[[plate]], str_detect(condition, 'NT sgRNAs'))$Nuclei_Number)
  
    empty_df_plate[nrow(empty_df_plate) + 1,] <- c(trial_Name, paste0(neg_Ctrl, "_", trial_Name), mean_Nuc_Foci_NegCtrl, mean_Cell_NegCtrl, mean_Ratio_MLF2_NegCtrl, mean_Size_MLF2_NegCtrl, NA, sd_Nuc_Foci_NegCtrl, NA, CV_Nuc_Foci_NegCtrl, NA,  NA, paste0(neg_Ctrl, "_", trial_Name), mean_Nuc_Foci_NegCtrl_Top, sd_Nuc_Foci_NegCtrl_Top)
   

    #POSITIVE CONTROL:
    #-------------------------------------------------
      #Statistics for the negative control:
    mean_Nuc_Foci_PosCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$mean_Nuc_Foci)
    sd_Nuc_Foci_PosCtrl <- sd(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$mean_Nuc_Foci)
    
      mean_Nuc_Foci_NegCtrl_Top <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$mean_NucFociTop)
    sd_Nuc_Foci_NegCtrl_Top <- sd(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$mean_NucFociTop)
    
    #Coefficient of Variation (standard deviation / mean), lower = less variation across replicates. We are looking for CV < 15%
      #Most important for negative control, but might as well calculate for all wells.
    CV_Nuc_Foci_PosCtrl <- cv(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$mean_Nuc_Foci) * 100
    
    #Cytoplasm
    #mean_Cyto_Foci_PosCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Ctrl'))$mean_Cyto_Foci)
    #Optional
    #sd_Cyto_Foci_NegCtrl <- sd(Negative_Ctrl$mean_Cyto_Foci)
    
    #Nuclei Count:
    mean_Cell_PosCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$Nuclei_Number)
    
    
    mean_Ratio_MLF2_PosCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$Ratio_totalMLF2_vs_Cyto)
    mean_Size_MLF2_PosCtrl <- mean(filter(individual_Plates[[plate]], str_detect(condition, 'Tor1A_1B'))$Avg_Size_Foci)
    
    #Z score is comparing individual wells with the control wells. Essentially a z-test for large, normally distributed datasets where we know population mean and standard deivation.
    #We want one sample z test: Make sure that mu is the mean of the control population!!!!!!!!!!!!!!!!!!!!!!!!!!
    #Start with two-sided one sample z-test, but can adjust if we are getting to many hits that are increasing foci to a one sided one sample z-test.
    #Repeat for every sample
   
    #Z prime (1 - 3*(sd(averaged values for negative control replicates) + sd(averaged values for drug replicates))) / abs(mean(averaged values for negative control replicates) - mean(averaged values for drug replicates)))
    z_prime_Nuc_Foci <- 1 - ((3*sd_Nuc_Foci_PosCtrl + 3*sd_Nuc_Foci_NegCtrl) / abs(mean_Nuc_Foci_PosCtrl - mean_Nuc_Foci_NegCtrl))
    #z_prime_Cyto_Foci <- 1 - ((3*sd_Cyto_Foci + 3*sd_Cyto_Foci_NegCtrl) / abs(mean_Cyto_Foci - mean_Cyto_Foci_NegCtrl))
    
    #Coefficient of Variation (standard deviation / mean), lower = less variation across replicates. We are looking for CV < 15%
    #Most important for negative control, but might as well calculate for all wells.
    #CV corresponds to the cv(mean of replicates)
    CV_Nuc_Foci_Percent <- cv(mean_Nuc_Foci_PosCtrl) * 100
    #Optional
    # CV_Cyto_Foci_Percent <- cv(well_Cyto_Foci) * 100
    
    #Signal to Background noise ratio (S/B) = mean(signal) / mean(background), where background = negative control:
    #We are looking for a S/B ratio > 5
    #SB = mean of replicates(nagative ctrl) / mean of replicates(Drug)
    SB_Nuc_Foci <-  mean_Nuc_Foci_NegCtrl /mean_Nuc_Foci_PosCtrl
    #Optional
    # SB_Cyto_Foci <-  mean_Cyto_Foci_NegCtrl /mean_Cyto_Foci
    
    empty_df_plate[nrow(empty_df_plate) + 1,] <- c(trial_Name, paste0(pos_Ctrl, "_", trial_Name), mean_Nuc_Foci_PosCtrl, mean_Cell_PosCtrl, mean_Ratio_MLF2_PosCtrl, mean_Size_MLF2_PosCtrl, SB_Nuc_Foci, sd_Nuc_Foci_PosCtrl, z_prime_Nuc_Foci, CV_Nuc_Foci_PosCtrl, NA,  NA, paste0(pos_Ctrl, "_", trial_Name), mean_Nuc_Foci_NegCtrl_Top, sd_Nuc_Foci_NegCtrl_Top)
    
    
     
    
    #EACH CONDITION:
    #-----------------------------------------
    #Creates a list containing all unique wells, removes the positive and negative controls so only the test conditions are being analyzed.
    list_wells <- individual_Plates[[plate]][!grepl("NT |Ctrl|Nup98|PLK1|Tor1A_1B_", individual_Plates[[plate]]$condition), ]
    list_wells <- unique(list_wells$condition)
  
    #Iterates the statistical analysis function across each well (condition) besides controls.
    for (cond in list_wells){
        
  
       stats_Df[nrow(stats_Df) + 1,] <- statistical_Analysis_compounds(individual_Plates[[plate]][individual_Plates[[plate]]$Well_Num == cond, ])
       temp_stats_Df[nrow(temp_stats_Df) + 1,] <- statistical_Analysis_compounds(individual_Plates[[plate]][individual_Plates[[plate]]$Well_Num == cond, ])
    }
    
    
    
    # #Normalization of Compounds [Negative effect = 0%; Positive effect = 100%]
    neg_control <- mean_Nuc_Foci_NegCtrl
    pos_control <- mean_Nuc_Foci_PosCtrl
  
    #Normalization of Compounds [Negative effect = 0%; Positive effect = 100%]

    #"Blanking" the Foci:
    #temp_stats_Df$Normalized <- (as.numeric(temp_stats_Df$Average_foci_perCell) - neg_control)

    #Reverse normalization
    #temp_stats_Df$Normalized <- (neg_control - as.numeric(temp_stats_Df$Average_foci_perCell)) / (neg_control - pos_control)
    
    #This is the normalized value only taking negative control into account:
   # temp_stats_Df$Normalized <- (as.numeric(temp_stats_Df$Average_foci_perCell) - neg_control) / (neg_control)
     temp_stats_Df <- temp_stats_Df[!is.na(temp_stats_Df$Plate),]

    #Converts that effect into percent effect:
    #stats_Df$Normalized_Effect <- (as.numeric(temp_stats_Df$Average_foci_perCell) - neg_control) / (pos_control - neg_control) * 100
    temp_stats_Df$Normalized_Effect <- ((as.numeric(temp_stats_Df$Average_foci_perCell) - neg_control) /  neg_control) * 100
    #Normalizes to both the 25% top control and gene
    
    mean_population <- mean(as.numeric(temp_stats_Df$mean_NucFociTop))
    temp_stats_Df$Normalized_Effect_Top <- ((as.numeric(temp_stats_Df$mean_NucFociTop) - mean_population) /  mean_population) * 100

    # Normalized_SD <- sd(temp_stats_Df[c(3:length(temp_stats_Df$Normalized)), "Normalized"])
    # Normalized_SD_Top <- sdsd(temp_stats_Df[c(3:length(temp_stats_Df$Normalized)), "Normalized"])
  
    #Takes the mean and standard deviation of the normalization of the screening population
    #NOTE: WILL REMOVE THE FIRST TWO CONDITIONS AS THOSE WERE SET TO BE THE POSITIVE AND NEGATIVE CONTROLS
    #stats_Df_WithoutCtrls <- temp_stats_Df[!grepl("NT sgRNAs|Ctrl", stats_Df$Well_Condition), ]
    #Normalized_SD <- sd(stats_Df$Normalized[c(3:length(stats_Df$Normalized))])
  
    #Repeat the mean and standard deviation of the normalized percent effect of the screening population
    Normalized_mean_Effect <- mean(temp_stats_Df$Normalized_Effect)
    Normalized_SD_Effect <- sd(temp_stats_Df$Normalized_Effect)
  
    Normalized_mean_Effect_Top <- mean(temp_stats_Df$Normalized_Effect_Top)
    Normalized_SD_Effect_Top <- sd(temp_stats_Df$Normalized_Effect_Top)
  
    
    #IntraPlate Z score:
    #IntraPlate Z score:
    
    #Use IntraPlateZscore top vs top
    temp_stats_Df$IntraPlateZScoreTopvsTop <- ((as.numeric(temp_stats_Df$Normalized_Effect_Top) - Normalized_mean_Effect_Top) /  Normalized_SD_Effect_Top)  
    temp_stats_Df$IntraPlateZScoreTopvsAll <- ((as.numeric(temp_stats_Df$Normalized_Effect_Top) - Normalized_mean_Effect) /  Normalized_SD_Effect) 

    #If excluding the controls:   
    # Normalized_mean_Effect <- mean(temp_stats_Df[3:nrow(temp_stats_Df), ]$Normalized_Effect)
    # Normalized_SD_Effect <- sd(temp_stats_Df[3:nrow(temp_stats_Df), ]$Normalized_Effect)
  
      
    mean_minus_3SD <- Normalized_mean_Effect - 3*Normalized_SD_Effect
    mean_plus_3SD <- Normalized_mean_Effect + 3*Normalized_SD_Effect
    
    
    
    #Returns a list of the Z score normalization (standardization) of the entire screen. Putative screen actives are (+/- 3)
    #stats_Df$Normalized_SD <- (temp_stats_Df$Normalized - Normalized_mean) / Normalized_SD
    
    #DO THIS AFTER ALL PLATES ARE FINISHED
    #$Normalized_SD <- (temp_stats_Df$Normalized - mean(temp_stats_Df[c(3:length(temp_stats_Df$Normalized)), "Normalized"]) / Normalized_SD)
    
    #Add cytotoxicity results:
    #stats_Df$Viability <-  round((as.numeric(temp_stats_Df$Average_Cell_Count)/mean_Cell_NegCtrl)*100, 2)
    temp_stats_Df$Viability <-  round((as.numeric(temp_stats_Df$Average_Cell_Count)/mean_Cell_NegCtrl)*100, 2)
  
    #Round all the data:
    numerical <- sapply(stats_Df, is.numeric)
    stats_Df[numerical] <- lapply(stats_Df[numerical], function(x) round(x, digits = 2))
    
    numerical <- sapply(temp_stats_Df, is.numeric)
    temp_stats_Df[numerical] <- lapply(temp_stats_Df[numerical], function(x) round(x, digits = 2))
    #stats_Df <- stats_Df[, c(1,2,10,12,14,13,3,5,6,11,4,7,9,8)]
    
    #This adds the plate number into the corresponding well ID for each condition. Only necessary if analyzing multiple plates in a high throughput screen
    #stats_Df$Well_Condition <- paste(stats_Df$Well_Condition, plate_num, sep = "_")
    
    #Re-order columns of dataframe to make simpler to interpret:
    #merged_Df <- rbind(merged_Df, stats_Df)
  
  
    current_Plate <-individual_Plates[[plate]][individual_Plates[[plate]]$plate_Num == trial_Name,  ]
  
 
    #Convert to matrix format for the following polish optimization:
      
    temp_df <- temp_stats_Df[c(1:length(temp_stats_Df$Well_Condition)), c(2,13)]
    temp_df <- drop_na(temp_df)
    #as.matrix(stats_Df[, c(2,3)])
    
    letters <- substr(temp_df$Well_Condition, 1, 1)
    
    numbers <- as.numeric(substr(temp_df$Well_Condition, 2, nchar(as.character(temp_df$Well_Condition))))
    
    unique_letters <- unique(letters)
    unique_numbers <- unique(numbers)
    
    sort_num <- sort(unique_numbers)
    
    mtx <- matrix(NA, nrow =length(unique_letters), ncol =length(unique_numbers), dimnames = list(unique_letters, unique_numbers))
    
    
    for (i in 1:nrow(temp_df)) {
      
      row_index <- match(letters[i], rownames(mtx))
      col_index <- match(numbers[i], colnames(mtx))
      
      # Assign the value to the corresponding position in the matrix
      mtx[row_index, col_index] <- as.numeric(temp_df$Normalized_Effect_Top[i])
      #mtx[letters, numbers] <- df2$Average_foci_perCell[i]
    }
    
    
    #See the following sources for the statistical reasoning:     #https://academic.oup.com/bioinformatics/article/28/13/1775/235775
    #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4653387/
    #Delivering Robust Candidates to the Drug Pipeline through Computational Analysis of Arrayed CRISPR Screens
    
    #Use Median Polish Normalization across rows and columns. Take the residuals after data converges.
    suppress_output <- capture.output({
      mtx_Polish <- medpolish(mtx)
      })
    
    
    flush.console()
    residuals <- mtx_Polish$residuals
    #Calculate difference between raw measurements and the fitted Polish values
    #mtx_Adjusted_rijp <- mtx - residuals
    #Calc median of that fitted matrix.
    median_residuals <- median(residuals)
    #Calculate the median absolute deviation and subtract accordingly
    MAD <- median(abs(residuals - median_residuals))

    #Calculate B-score by taking adjusted matrix and dividing by MAD
    bScore <- residuals / MAD

    #Convert back into dataframe format
    row_names <- rownames(bScore)
    col_names <- colnames(bScore)

    BScoreDf <- data.frame(names = character(0), values = numeric(0))

    # Loop through each element in the matrix
    for (i in 1:nrow(bScore)) {
      for (j in 1:ncol(bScore)) {
        # Get the name by concatenating row and column names
        Well_Condition <- paste0(row_names[i], sprintf("%02d", as.numeric(col_names[j])))

        # Get the corresponding value from the matrix
        Bscores <- bScore[i, j]

        # Add the name-value pair to the dataframe
        BScoreDf <- rbind(BScoreDf, data.frame(Well_Condition = Well_Condition, BScore = Bscores))
      }
    }


    #Use locally weighted scatterplot smoothing (LOWESS) algorithm to smooth data and adjust for well variability (should definitely use if expecting high number of hits)
    BScoreDf_LOWESS <- lowess(BScoreDf)$y

    BScoreDf$LOWESS <- BScoreDf_LOWESS

    #Finally, correct the Bscore values:

    BScoreDf$Corrected_BScore <- BScoreDf$BScore - (BScoreDf$LOWESS - median(BScoreDf$LOWESS))

    temp_stats_Df <- merge(temp_stats_Df, BScoreDf, by = "Well_Condition")




    #Creates 384-well plate layouts so that we can analyze edge effects, experimental error patterns, etc. Credit goes to ggplate.
    plate_Visualization <- current_Plate %>%
      group_by(Well_Num) %>%
      summarise(Nuc_Foci = mean_Nuc_Foci, Nuc_Count = Nuclei_Number)
    
    nuc_plate <- plate_plot(
      data = plate_Visualization,
      position = Well_Num,
      value = Nuc_Foci,
      plate_size = 384,
      label = round(Nuc_Foci, 0),
      title = paste(trial_Name,  ", Nuclear Foci:", sep =""),
      title_size = 14,
      label_size = 1.6,
      colour =c("#FF0000", "#006600", "#006600", "#00CC00", "#00FF00"))
    
   
    
    cell_plate <- plate_plot(
      data = plate_Visualization,
      position = Well_Num,
      value = Nuc_Count,
      plate_size = 384,
      label = round(Nuc_Count),
      title = paste(trial_Name,  ", Cell Count:", sep =""),
      title_size = 14,
      label_size = 1.6,
      colour = c("#FF0000", "#006600", "#006600", "#00CC00", "#00FF00")
    )
    
    
    #Creates a function to export the raw distribution of the data
    raw_Distribution <- ggplot(temp_stats_Df, aes(x = as.numeric(Average_foci_perCell ))) +
    geom_histogram(color = "black", fill = "darkred", binwidth=0.25) +
    geom_density(alpha = 0.6, fill = "darkgray" ) +
    labs(title = paste("Distribution of ", foci_Type, ": Plate ", trial_Name,  sep =""),  y = "Count", x = foci_Type) +
    theme_classic()
    
    
    #Creates a function to export the normalized distribution of the data
    normalized_Dist <- ggplot(temp_stats_Df, aes(x = Normalized_Effect)) +
    geom_histogram(color = "black", fill = "darkred", binwidth = 2) +
    geom_density(alpha = 0.6, fill = "darkgray" ) +
    
    geom_vline(aes(xintercept = 100), linetype = 'dashed', size = 1) +
    annotate("text", x=97, y=15, label = pos_Ctrl, angle=90, size = 3.5) +
    geom_vline(aes(xintercept = 0), linetype = 'dashed', size = 1) +
    annotate("text", x=-3, y=15, label=paste0(neg_Ctrl, "Ctrl"), angle=90, size = 3.5) +
    
    geom_vline(aes(xintercept = mean_plus_3SD), linetype = 'dashed', color = "red", size = 1) +
    annotate("text", x=mean_plus_3SD - 3, y=15, label="(-) 3SD", angle=90, size = 3.5) +
    
    geom_vline(aes(xintercept = mean_minus_3SD), linetype = 'dashed', color = "red", size = 1) +
    annotate("text", x=mean_minus_3SD - 3, y=15, label="(+) 3SD", angle=90, size = 3.5) +
    
    labs(title = paste("Normalized Effect on ", foci_Type, ": Plate ", trial_Name,  sep =""), y = "Count", x = paste("% Decrease in ", foci_Type, sep = "")) +
    theme_classic()
    
    
    #Add plots for BScore/LOWESS
    lowess_plot <- ggplot(BScoreDf, aes(x = Well_Condition, y = LOWESS)) + 
      geom_point(color = "darkred") +   
      theme_classic() +
      theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
      labs(x = "Well Location (upper right to bottom left)", y = "Fitted Values", title = paste("B-Score with LOWESS Regression: ", trial_Name)) +
      theme(axis.title=element_text(size=10))  
    
    bscore_plot <- ggplot(BScoreDf, aes(x = Well_Condition, y = BScore)) + 
      geom_point(color = "darkred") +   
      theme_classic() +
      theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
      labs(x = "Well Location (upper right to bottom left)", y = "B-Score", title = paste("B-Score ScatterPlot: ", trial_Name)) +
      theme(axis.title=element_text(size=10))
    


    #Export the images:
    ggsave(filename = paste0(file_Location,"nuc_plate.png"), plot = nuc_plate, width = 6, height = 3)
    #ggsave(filename = paste0(file_Location,"cyto_plate.png"), plot = cyto_plate, width = 6, height = 3)
    ggsave(filename = paste0(file_Location,"cell_plate.png"), plot = cell_plate, width = 6, height = 3)
    ggsave(filename = paste0(file_Location,"Normalized_Dist_plate.png"), plot = normalized_Dist, width = 6, height = 3)
    ggsave(filename = paste0(file_Location, "Raw_Dist.png"), plot = raw_Distribution, width = 6, height = 3)
    ggsave(filename = paste0(file_Location, "bscoreplot.png"), plot = bscore_plot, width = 6, height = 3)      
    ggsave(filename = paste0(file_Location, "lowessplot.png"), plot = lowess_plot, width = 6, height = 3)
    
    
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"Normalized_Dist_plate.png"),startRow = 1, startCol = 1)
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"Raw_Dist.png"),startRow = 1, startCol = 9)
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"nuc_plate.png"),startRow = 15, startCol = 1)
    #insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"cyto_plate.png"),startRow = 15, startCol = 9)
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"cell_plate.png"),startRow = 30, startCol = 1)
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"bscoreplot.png"),startRow = 45, startCol = 1)    
    insertImage(wb, sheet = paste0("Figures_", trial_Name), paste0(file_Location,"lowessplot.png"),startRow = 45, startCol = 9)
  
    #Can uncomment this section to save the exported graphs directly as a Tiff file
    tiff(paste(image_Save_Location, "plate_visualizations_", trial_Name, ".tiff" ,sep = ""), units="in", width=20, height=12, res=400)
    ggarrange(nuc_plate, cell_plate, heights = c(10, 10))
    dev.off()
    
     
    #Merge Datasets:
    #merged_Df_temp <- cbind(stats_Df[, cbind(1,2)], temp_stats_Df[, 3:ncol(temp_stats_Df)])
    #merged_Df <- rbind(merged_Df, temp_stats_Df) 
    temp_stats_Df <- transform(temp_stats_Df, Average_foci_perCell = as.numeric(Average_foci_perCell))
    temp_stats_Df <- transform(temp_stats_Df, Average_Cell_Count = as.numeric(Average_Cell_Count))
    #temp_stats_Df <- transform(temp_stats_Df, Average_Cyto_Foci = as.numeric(Average_Cyto_Foci))
    temp_stats_Df <- transform(temp_stats_Df, SB_Nuc_Foci = as.numeric(SB_Nuc_Foci))
    #temp_stats_Df <- transform(temp_stats_Df, SD_Nuc_Foci = as.numeric(SD_Nuc_Foci))
    # temp_stats_Df <- transform(temp_stats_Df, Z_prime_Nuc_Foci = as.numeric(Z_prime_Nuc_Foci))
    # temp_stats_Df <- transform(temp_stats_Df, CV_Nuc_Foci = as.numeric(CV_Nuc_Foci))
    
    temp_stats_Df$Average_foci_perCell <- as.numeric(temp_stats_Df$Average_foci_perCell)
    numerical <- sapply(temp_stats_Df, is.numeric)
    
    
    temp_stats_Df[numerical] <- lapply(temp_stats_Df[numerical], function(x) round(x, digits = 2))
 
  
    # Append the new data to the existing data
    existing_data <- read.xlsx(wb, sheet = "Raw_Data")
    existing_plate_data <- read.xlsx(wb, sheet = "Plate Statistics")
  
     
    # Write the updated data to the same worksheet
    #writeData(wb, sheet = "Raw_Data", x = temp_stats_Df, startCol = 1, startRow = nrow(existing_data) + 3, append = TRUE)
    combined_data <- rbind(existing_data, temp_stats_Df)
    
    numerical_plate <- sapply(empty_df_plate, is.numeric)
    empty_df_plate[numerical_plate] <- lapply(empty_df_plate[numerical_plate], function(x) round(x, digits = 2))
    
    combined_plate_data <- rbind(existing_plate_data, empty_df_plate)
    plate_numeric <-  colnames(combined_plate_data[, c(2, 3,4,5,6,7,8,9,10,11,12,13)])
    combined_plate_data[plate_numeric] <- lapply(lapply(combined_plate_data[plate_numeric],as.numeric), function(x) round(x, digits = 2))

    # Write the combined data back to the same worksheet
    writeData(wb, sheet = "Raw_Data", x = combined_data, startCol = 1, startRow = 1)
    writeData(wb, sheet = "Plate Statistics", x = combined_plate_data, startCol = 1, startRow = 1)

    saveWorkbook(wb, save_Location, overwrite = TRUE)

  flush.console()
  
  }

}






```
  
  



```{r}
options(scipen = 999)

#Only uncomment once finished analyzing all data!!!
#wb <- loadWorkbook(save_Location)
wb <- loadWorkbook(save_Location)

#Round the plate statistics (if not previously done)
plate_stats <- read.xlsx(wb, sheet = "Plate Statistics")
plate_numeric <-  colnames(plate_stats[, c(3,4,5,6,7,8,9,10,11,12)])
plate_stats[plate_numeric] <- lapply(lapply(plate_stats[plate_numeric],as.numeric), function(x) round(x, digits = 2))
writeData(wb, "Plate Statistics", plate_stats)



merged_df <- read.xlsx(wb, sheet = "Raw_Data")
combined_across_sqls <- merged_df
#combined_across_sqls <-  combined_across_sqls[!grepl("WellCondition", combined_across_sqls$Drug.Information), ]
combined_across_sqls$Average_foci_perCell <- as.numeric(combined_across_sqls$Average_foci_perCell)
combined_across_sqls$Normalized_Effect <- as.numeric(combined_across_sqls$Normalized_Effect)
#combined_across_sqls$Normalized_SD <- as.numeric(combined_across_sqls$Normalized_SD)



gene_template <- read.xlsx(paste0(file_Location, "20231221_Schlieker WT CRISPR Screen_Report.xlsx"))
gene_template <- gene_template[, c("Plate.Name", "Plate.Well", "Gene.Symbol")]
colnames(gene_template)[1] <- "Plate"
colnames(gene_template)[2] <- "Well_Condition"
colnames(gene_template)[3] <- "Gene"

merged_df <- merge(gene_template, combined_across_sqls, by = c("Plate", "Well_Condition"), all = TRUE)
merged_df <- na.omit(merged_df)

#Average duplicates:
# merged_df <- merged_df %>% 
#   group_by(Gene) %>%
#   summarize()


putatives <- read.xlsx(wb, sheet = "Putative Actives")


merged_Df_NoCtrls <- merged_df[!grepl("NT|Ctrl|Well_Condition|PLK1|Nup98|Tor1A_1B", merged_df$Well_Condition), ]
#screen_Actives_Df_merged <- merge(gene_template, screen_Actives_Df, by = c("Plate", "Well_Condition"))

merged_Df_NoCtrls$Z_Score <-  ((merged_Df_NoCtrls$Corrected_BScore - mean(merged_Df_NoCtrls$Corrected_BScore)) / sd(merged_Df_NoCtrls$Corrected_BScore))
merged_Df_NoCtrls$Z_Score <- round(merged_Df_NoCtrls$Z_Score, 2)


#merged_Df_NoCtrls <- na.omit(merged_Df_NoCtrls)
screen_Actives_Df <- merged_Df_NoCtrls[merged_Df_NoCtrls$Z_Score > 2.5 | merged_Df_NoCtrls$Z_Score <= -2.5, ]

merged_Df_NoCtrls <- merged_Df_NoCtrls[order(merged_Df_NoCtrls$Z_Score, decreasing = T), ]
screen_Actives_Df <- screen_Actives_Df[order(screen_Actives_Df$Z_Score, decreasing = T), ]

merged_Df_NoCtrls <- merged_Df_NoCtrls[, c(1,2,3,16, 4,5,6,7,8,9,10,11,12,13,14,15,20)]
screen_Actives_Df <- screen_Actives_Df[, c(1,2,3,16, 4,5,6,7,8,9,10,11,12,13,14,15,20)]
#Writes the wells of interest to the XLSX sheet
writeData(wb, "Putative Actives", screen_Actives_Df)
writeData(wb, "Raw_Data", merged_Df_NoCtrls)



normalized_Sd_Bar <- ggplot(data = merged_Df_NoCtrls, aes(x=paste0(Well_Condition, Plate), y = Z_Score, fill = factor(ifelse(Z_Score >= 2.5, "tofill", "nottofill")))) +
  geom_segment(data = filter(merged_Df_NoCtrls, Z_Score >= 2.5),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "red", size = 0.5) +
  geom_segment(data = filter(merged_Df_NoCtrls, Z_Score < 2.5),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "black", size =0.1 )+
  geom_segment(data = filter(merged_Df_NoCtrls, Gene == "TOR1B"),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "green", size =1 )+
      scale_fill_manual(values = c("tofill" = "red", "nottofill" ="gray27")) +

   theme_classic() +
   theme(axis.title.x=element_blank(),
         axis.text.x=element_blank(),
         axis.ticks.x=element_blank(),) +
# #Edit title as needed
# #------------------------------------------------------------------
   labs(y = "Z-Score", x = "sgRNA", title = "sgRNAs of Interest (WT CRISPR Screen):") +
# #------------------------------------------------------------------
#
  scale_y_continuous(limits = c(-10, -3, 0, 3, 5, 10)) +
  scale_y_continuous(breaks=c( 0, 2, 4,6,8,10)) +
  geom_hline(yintercept = c(2.5), color = "darkred", linetype = "dashed", size = 0.5) +
  geom_text_repel(data = filter(merged_Df_NoCtrls, Z_Score >= 2.5 ), aes(label = paste0(Gene)), box.padding = 0.3, size = 2.75, max.overlaps = Inf) +
  guides(fill="none")+
  theme(plot.title = element_text(size = 18)) +
  theme(axis.title = element_text(size = 16)) 
  #coord_cartesian(ylim = c(-4.2, 4))

normalized_Sd_Bar


# tiff(paste(image_Save_Location, "normalized_WT_Confidential.tiff", sep = ""), units="in", width=14, height=10, res=300)
# print(normalized_Sd_Bar)
# dev.off()

#Creates a function to return bar graph of all wells with a line at the screening threshold
#--------------
#Version for Viability
# merged_Df_NoCtrls
# merged_Df_NoCtrls$Lethality <- (100 - merged_Df_NoCtrls$Viability)
# 
# for (i in 1:length(merged_Df_NoCtrls$Lethality)){
#   if (merged_Df_NoCtrls$Lethality[i] > 80 | merged_Df_NoCtrls$Lethality[i] < -40){
#     screen_Active <- c(merged_Df_NoCtrls$Plate[i], merged_Df_NoCtrls$Well_Condition[i], merged_Df_NoCtrls$Normalized_SD[i], merged_Df_NoCtrls$Average_foci_perCell[i], merged_Df_NoCtrls$Average_Cell_Count[i], merged_Df_NoCtrls$Normalized_Effect[i], merged_Df_NoCtrls$Lethality[i], paste0(merged_Df_NoCtrls$Well_Condition[i], "_", trial_Name))
#      screen_Actives_Df <- rbind(screen_Actives_Df, screen_Active)}
#   }
# #--------------
# 
# filtered_data <- merged_Df_NoCtrls %>%
#   filter(Lethality > 80 | Lethality < -40)
# 
# 
# normalized_Sd_Bar_viability <- ggplot(data = filtered_data, aes(x=Gene, y = Lethality, fill = factor(ifelse(Lethality > 80 | Lethality < -40, "tofill", "nottofill")))) +
#   
#   geom_segment(data = filtered_data,
#                aes(x = Gene, xend = Gene, y = 0, yend = Lethality),
#                color = "red", size = 0.5) +
#   
#   geom_segment(data = filter(merged_Df_NoCtrls,  Lethality <= 80 & Lethality >= -40 ),
#                aes(x = Gene, xend = Gene, y = 0, yend = Lethality),
#                color = "black", size =0.001)+
#       scale_fill_manual(values = c("tofill" = "red", "nottofill" ="gray27")) +
# 
#    theme_classic() +
#    theme(axis.title.x=element_blank(),
#          axis.text.x=element_blank(),
#          axis.ticks.x=element_blank(),) +
# # #Edit title as needed
# # #------------------------------------------------------------------
#    labs(y = "Lethality Relative to NT sgRNA", x = "sgRNA", title = "Lethality 4TorKO CRISPR Screen:") +
# # #------------------------------------------------------------------
# #
#   scale_y_continuous(limits = c(-100, -50, -25, 0, 25, 50, 75, 100)) +
#   scale_y_continuous(breaks=c(-100, -50, -40, -25, 0, 25, 50, 75,80, 100),  labels = function(x) paste0(x, "%")) +
#   geom_hline(yintercept = c(80), color = "darkred", linetype = "dashed", size = 0.5) +
#   geom_hline(yintercept = c(-40), color = "darkred", linetype = "dashed", size = 0.5) +
# 
#   #geom_text_repel(data = filter(merged_Df_NoCtrls, Lethality > 80 | Lethality < -40), aes(label = paste0(Gene)), box.padding = 0.3, size = 3, max.overlaps = Inf) +
#   geom_text_repel(data = filtered_data, aes(label = paste0(Gene)), box.padding = 0.3, size = 3, max.overlaps = Inf) +
#   guides(fill="none")+
#   theme(plot.title = element_text(size = 18)) +
#   theme(axis.title = element_text(size = 16))
# 
# # #Exports and saves normalized bar graph directly as a Tiff file
# normalized_Sd_Bar
# tiff(paste(image_Save_Location, "normalized_MLF2_GFP_4TorKO_top60percent_nopositivectrl.tiff", sep = ""), units="in", width=14, height=10, res=300)
# print(normalized_Sd_Bar)
# dev.off()


#Inserts the normalized bar plot to excel worksheet
normalized_Sd_Bar
insertPlot(wb, sheet = "Combined Analysis", startRow = 1, startCol = 1, width = 10, height = 6)






# #Graph showing the raw distribution for ALL the combined plates

raw_Distribution <- ggplot(merged_Df_NoCtrls, aes(x = Average_foci_perCell )) +
  geom_histogram(color = "black", fill = "darkred", binwidth = 0.05) +
  geom_density(alpha = 0.6, fill = "darkgray" ) +
  labs(title = paste("Distribution of ", foci_Type, " (WT CRISPR KO Screen):", sep = ""),  y = "Count (top 50% of cells)", x = foci_Type) +
  theme_classic()
raw_Distribution


normalized_Dist <- ggplot(merged_Df_NoCtrls, aes(x = Normalized_Effect)) +
  geom_histogram(color = "black", fill = "darkred", binwidth = 1) +
  geom_density(alpha = 0.6, fill = "darkgray" ) +

  geom_vline(aes(xintercept = 100), linetype = 'dashed', size = 1) +
  annotate("text", x=96, y=1000, label="Torsin1A/1B KO Ctrl", angle=90, size = 4) +
  geom_vline(aes(xintercept = 0), linetype = 'dashed', size = 1) +
  annotate("text", x=-6, y=1000, label= paste0(neg_Ctrl, "NT Ctrl"),  color = "black", angle=90, size = 4) +


  # geom_vline(aes(xintercept = mean_minus_3SD), linetype = 'dashed', color = "red", size = 1) +
  # annotate("text", x=mean_minus_3SD - 4, y=25, label="(-) 3SD", angle=90, size = 5) +

  labs(title = paste("Normalized Effect on ", foci_Type, " (WT CRISPR KO Screen):", sep = ""), y = "Gene Count", x = paste("% Increase Relative to NT sgRNA", foci_Type, sep = "")) +
  theme_classic() +
  theme(title = element_text(size = 14))+
  theme(axis.title.x = element_text(size = 14))
# 
# # #Exports graphs as TIFF files
# normalized_Dist
# tiff(paste(image_Save_Location, "distrpilot_", plate_num, ".tiff" ,sep = ""), units="in", width=12, height=10, res=400)
# ggarrange(normalized_Dist, heights = c(6, 6))
# dev.off()
# 
# raw_Distribution
# tiff(paste(image_Save_Location, "rawdistrpilot_", plate_num, ".tiff" ,sep = ""), units="in", width=6, height=6, res=400)
# ggarrange(raw_Distribution, heights = c(6, 6))
# dev.off()

#Inserts plots of combined plate analysis into the XLSX sheet
raw_Distribution
insertPlot(wb, sheet = "Combined Analysis", startRow = 35, startCol = 1, width = 6, height = 4)

normalized_Dist
insertPlot(wb, sheet = "Combined Analysis", startRow = 35, startCol = 10, width = 6, height = 4)


screen_Actives_Df <- screen_Actives_Df[-1,]
#write.xlsx(combined_across_sqls, file = save_Location, sheetName = "Raw_Data", append = TRUE)
write.xlsx(screen_Actives_Df, file = save_Location, sheetName = "Putative Actives", append = TRUE)

  
table(screen_Actives_Df$Normalized_SD)

#Save and export final version of the Excel Workbook:
saveWorkbook(wb, save_Location, overwrite = TRUE)



gene_templates <- gene_template[,c(4,16, 7, 8)]
colnames(gene_templates) <- c("Gene", "Z_Score", "Plate", "Well_Condition" )



normalized_Sd_Bar <- ggplot(data = gene_templates, aes(x=paste0(Well_Condition, Plate), y = Z_Score, fill = factor(ifelse(Z_Score >= 2.5, "tofill", "nottofill")))) +
  geom_segment(data = filter(gene_templates, Z_Score >= 2.5),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "red", size = 0.5) +
  geom_segment(data = filter(gene_templates, Z_Score < 2.5),
               aes(x = paste0(Well_Condition, Plate, alpha= 0), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "black", size =0.1, alpha = 0.4)+

  geom_segment(data = filter(gene_templates, Gene == "TOR1B"),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "blue", size =1 )+
  
  geom_segment(data = filter(gene_templates, Gene == "APOL3" | Gene == "LDLRAD1" | Gene == "LRP10" | Gene == "NUP50" | Gene == "MCOLN1"),
               aes(x = paste0(Well_Condition, Plate), xend = paste0(Well_Condition, Plate), y = 0, yend = Z_Score),
               color = "green", size =1)+
  
  
      scale_fill_manual(values = c("tofill" = "red", "nottofill" ="gray27")) +

   theme_classic() +
   theme(axis.title.x=element_blank(),
         axis.text.x=element_blank(),
         axis.ticks.x=element_blank(),) +
# #Edit title as needed
# #------------------------------------------------------------------
   labs(y = "Z-Score", x = "sgRNA", title = "sgRNAs of Interest (WT CRISPR Screen):") +
# #------------------------------------------------------------------
#
  scale_y_continuous(limits = c(-10, -3, 0, 3, 5, 10)) +
  scale_y_continuous(breaks=c( 0, 2, 4,6,8,10)) +
  geom_hline(yintercept = c(2.5), color = "darkred", linetype = "dashed", size = 0.5) +
  geom_text_repel(data = filter(gene_templates, Gene == "APOL3" | Gene == "TOR1B" | Gene == "LDLRAD1" | Gene == "LRP10" | Gene == "NUP50" | Gene == "MCOLN1" ), aes(label = paste0(Gene)), box.padding = 0.5, size = 3.5, max.overlaps = Inf) +
  guides(fill="none")+
  theme(plot.title = element_text(size = 18)) +
  theme(axis.title = element_text(size = 16)) 
  #coord_cartesian(ylim = c(-4.2, 4))

normalized_Sd_Bar


tiff(paste(image_Save_Location, "normalized_WT_ConfidentialVersion.tiff", sep = ""), units="in", width=14, height=10, res=300)
print(normalized_Sd_Bar)
dev.off()
















hitz <- as.list(merged_Df_NoCtrls[c(1:7, 9:11), "Gene.x"])
hitz <- hitz[c(1:9, 11),]



normalized_Sd_Bar <- ggplot(data = merged_Df_NoCtrls, aes(x=paste0(Plate, Well_Condition), y = Z_Score, fill = factor(ifelse(Z_Score >= 2.5, "tofill", "nottofill")))) +
  geom_segment(data = filter(merged_Df_NoCtrls, Z_Score >= 3),
               aes(x = paste0( Plate, Well_Condition), xend = paste0(Plate, Well_Condition), y = 0, yend = Z_Score),
               color = "red", size = 0.5) +
  geom_segment(data = filter(merged_Df_NoCtrls, Z_Score < 2.5),
               aes(x = paste0(Plate, Well_Condition), xend = paste0(Plate, Well_Condition), y = 0, yend = Z_Score),
               color = "black", size =0.1 )+
  geom_segment(data = filter(merged_Df_NoCtrls, Gene.y == "TOR1B" | Gene.y == "TOR1A"),
               aes(x = paste0(Plate, Well_Condition), xend = paste0(Plate, Well_Condition), y = 0, yend = Z_Score),
               color = "green", size =2 )+
  
  # 
  #  
  # geom_segment(data = filter(merged_Df_NoCtrls, Gene.y %in% hitz),
  #              aes(x = paste0(Plate, Well_Condition), xend = paste0(Plate, Well_Condition), y = 0, yend = Z_Score),
  #              color = "red", size =1)+
  # 
  
      scale_fill_manual(values = c("tofill" = "red", "nottofill" ="gray27")) +

   theme_classic() +
   theme(axis.title.x=element_blank(),
         axis.text.x=element_blank(),
         axis.ticks.x=element_blank(),) +
# #Edit title as needed
# #------------------------------------------------------------------
   labs(y = "Z-Score (Significance)", x = "Gene", title = "Genome-Wide CRISPR KO Screen Recapitulating Cellular DYT1 Phenotype:") +
# #------------------------------------------------------------------
#

  geom_hline(yintercept = c(2), color = "darkred", linetype = "dashed", size = 0.5) +
 # geom_text_repel(data = filter(merged_Df_NoCtrls, Z_Score >= 2.5 ), aes(label = paste0(Gene.y)), box.padding = 0.3, size = 2.75, max.overlaps = Inf) +
  geom_text_repel(data = filter(merged_Df_NoCtrls, Gene.y == "TOR1B" | Gene.y == "TOR1A" ), aes(label = paste0(Gene.y)), box.padding = 0.3, size = 6, max.overlaps = Inf) +

 #geom_text_repel(data = filter(merged_Df_NoCtrls, Gene.y %in% hitz | Gene.y == "TOR1B" | Gene.y == "TOR1A"), aes(label = paste0(Gene.y)), box.padding = 0.5, size = 5.5, max.overlaps = Inf) +
  guides(fill="none")+
  theme(plot.title = element_text(size = 24)) +
  theme(axis.title = element_text(size = 20)) +
  
  scale_y_continuous(limits = c( 0, 3, 5, 10)) +
  scale_y_continuous(breaks=c( 0, 2, 4,6,8,10)) +
    coord_cartesian(ylim = c(0, 8)) 



tiff(paste(image_Save_Location, "normalized_WT_DMRFVersion.tiff", sep = ""), units="in", width=14, height=10, res=300)
print(normalized_Sd_Bar)
dev.off()


 
 
normalized_Sd_Bar
 
hitz <- hitz[c(1:8, 11),]


```


```{r}
# for (i in 1:length(image_Set_List)){
# 
#   df1_MLF2 <- fread(paste0(file_Location, foci_Set_List[i]), select = 1:3)
#   #df <- read.csv(paste0(file_Location, foci_Set_List[4]))
# 
#   per_image_nuc <- df1_MLF2 %>%
#   group_by(ImageNumber) %>%
#   summarise(Nuclei_Number = n(), mean_Nuc_Foci = mean(Children_MLF2_GFP_Count, na.rm = T))
# 
# 
#   MLF2_Area <-  fread(paste0(file_Location, image_Set_List[i]), select = c("AreaOccupied_AreaOccupied_MLF2_GFP", "AreaOccupied_AreaOccupied_Cyto", "Count_MLF2_GFP", "ImageNumber", "URL_GFP"))
#   #MLF2_image <- MLF2_image[, c(2,1, 11, 37)]
#   #MLF2_Area$URL_GFP <- MLF2_Area$URL_GFP
#   MLF2_Area$Ratio_totalMLF2_vs_Cyto <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$AreaOccupied_AreaOccupied_Cyto)
#   MLF2_Area$Avg_Size_Foci <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$Count_MLF2_GFP)
# 
# 
#   #Only use if there is an abberant dash between a random 2.... otherwise comment out
#   MLF2_Area <- MLF2_Area %>%
#   mutate_at(vars("URL_GFP"), funs(gsub("-2-", "", .)))
# 
#   #Extract plate, well and image number:
#   
#   #For 4TorKO cells
#   # plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "-")
#   # plate_Num_Temp <- sapply(plate_Num_Temp, "[[", 3)
#   # plate_Num_Temp <- str_split(plate_Num_Temp, "_")
#   # plate_Num <- sapply(plate_Num_Temp, "[[", 1)
#   # Well_Num <- sapply(plate_Num_Temp, "[[", 2)
#   # Image_Num <- sapply(plate_Num_Temp, "[[", 3)
# 
#   
#   #For WT Cells:
#   plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "_")[[1]]
#   Well_Num <- plate_Num_Temp[length(plate_Num_Temp) - 2] #9
#   Image_Num <- plate_Num_Temp[length(plate_Num_Temp) - 1] #10
#   plate_Num_Temp <- plate_Num_Temp[length(plate_Num_Temp) - 3] #8
#   plate_Num_Temp <- str_split(plate_Num_Temp, "-")[[1]]
#   plate_Num <-plate_Num_Temp[length(plate_Num_Temp)]
#   MLF2_Area$plate_Num <- plate_Num
#   MLF2_Area$Well_Num <- Well_Num
#   MLF2_Area$Imagecopy_Num <- Image_Num
# 
#   
#   
#   df <- (merge(per_image_nuc, MLF2_Area))
# 
#   df$condition <- df$Well_Num
#   df <- na.omit(df)
# 
#   #Groups all wells that share a single condition for aggregate statistics
#   per_Well_Plate <- df %>%
#   group_by(plate_Num, Well_Num, condition) %>%
#     #Filters out top image in case of screen aberration
#   filter(mean_Nuc_Foci < max(mean_Nuc_Foci)) %>%
#   summarise(Nuclei_Number = mean(Nuclei_Number, na.rm =T), mean_Nuc_Foci = mean(mean_Nuc_Foci, na.rm = T), Ratio_totalMLF2_vs_Cyto = mean(Ratio_totalMLF2_vs_Cyto, na.rm = T), Avg_Size_Foci = mean(Avg_Size_Foci, na.rm = T))
# 
# 
#   individual_Plates <- split(per_Well_Plate, f = per_Well_Plate$plate_Num)
# 
#  #------------------------------------------------- 
#   # #Version of code if there is an annoying "-" in path name: Otherwise comment out.
#   # df1_MLF2 <- fread(paste0(file_Location, "move_data/", foci_Set_List[i]), select = 1:3)
#   # #df <- read.csv(paste0(file_Location, foci_Set_List[4]))
#   # 
#   # per_image_nuc <- df1_MLF2 %>%
#   # group_by(ImageNumber) %>%
#   # summarise(Nuclei_Number = n(), mean_Nuc_Foci = mean(Children_MLF2_GFP_Count, na.rm = T))
#   # 
#   # 
#   # MLF2_Area <-  fread(paste0(file_Location, "move_data/",image_Set_List[i]), select = c("AreaOccupied_AreaOccupied_MLF2_GFP", "AreaOccupied_AreaOccupied_Cyto", "Count_MLF2_GFP", "ImageNumber", "URL_GFP"))
#   # #MLF2_image <- MLF2_image[, c(2,1, 11, 37)]
#   # #MLF2_Area$URL_GFP <- MLF2_Area$URL_GFP
#   # MLF2_Area$Ratio_totalMLF2_vs_Cyto <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$AreaOccupied_AreaOccupied_Cyto)
#   # MLF2_Area$Avg_Size_Foci <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$Count_MLF2_GFP)
#   #  
#   # 
#   # #Only use if there is an abberant dash between a random 2.... otherwise comment out
#   # MLF2_Area <- MLF2_Area %>%
#   # mutate_at(vars("URL_GFP"), funs(gsub("-2-", "_", .)))
#   # 
#   # #Extract plate, well and image number:
#   # plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "_")
#   # #plate_Num_Temp <- sapply(plate_Num_Temp, "[[", 3)
#   # #plate_Num_Temp <- str_split(plate_Num_Temp, "_")
#   # plate_Num <- sapply(plate_Num_Temp, "[[", 6)
#   # Well_Num <- sapply(plate_Num_Temp, "[[", 11)
#   # Image_Num <- sapply(plate_Num_Temp, "[[", 12)
#   # 
#   # MLF2_Area$plate_Num <- plate_Num
#   # MLF2_Area$Well_Num <- Well_Num
#   # MLF2_Area$Imagecopy_Num <- Image_Num
#   # 
#   # df <- (merge(per_image_nuc, MLF2_Area))
#   # 
#   # df$condition <- df$Well_Num
#   # df <- na.omit(df)
#   # 
#   # #Groups all wells that share a single condition for aggregate statistics
#   # per_Well_Plate <- df %>%
#   # group_by(plate_Num, Well_Num, condition) %>%
#   #   #Filters out top image in case of screen aberration
#   # filter(mean_Nuc_Foci < max(mean_Nuc_Foci)) %>%
#   # summarise(Nuclei_Number = mean(Nuclei_Number, na.rm =T), mean_Nuc_Foci = mean(mean_Nuc_Foci, na.rm = T), Ratio_totalMLF2_vs_Cyto = mean(Ratio_totalMLF2_vs_Cyto, na.rm = T), Avg_Size_Foci = mean(Avg_Size_Foci, na.rm = T))
#   # 
#   # 
#   # individual_Plates <- split(per_Well_Plate, f = per_Well_Plate$plate_Num)
#   # #Normally comment above out
# #----------------------------------------------
# 
# 
# }
#   
#   print(i)
#   
#    for (plate in 1:length(individual_Plates)){
#       
#       individual_Plates[[plate]]}}


```




```{r}

suppressMessages({
suppressWarnings({ 
for (i in 1:length(image_Set_List)){

  df1_MLF2 <- fread(paste0(file_Location, foci_Set_List[1]), select = 1:3)
#df <- read.csv(paste0(file_Location, foci_Set_List[4]))
  
  top_25 <- df1_MLF2 %>% 
group_by(ImageNumber) %>%
  arrange(ImageNumber, Children_MLF2_GFP_Count) %>%
  summarize(Children_MLF2_GFP_Count  = Children_MLF2_GFP_Count, ObjectNumber = ObjectNumber, nlen = ceiling(n() * 0.75))  

top_25_filtered <- top_25 %>%
  group_by(ImageNumber) %>%
  filter(row_number() > nlen)

top_25_filtered <- top_25_filtered[, c(1,3,2)]

  
  per_image_nuc <- top_25_filtered %>%
  group_by(ImageNumber) %>%
  summarise(Nuclei_Number = n(), mean_Nuc_Foci = mean(Children_MLF2_GFP_Count))
  
  MLF2_Area <-  fread(paste0(file_Location, image_Set_List[i]), select = c("AreaOccupied_AreaOccupied_MLF2_GFP", "AreaOccupied_AreaOccupied_Cyto", "Count_MLF2_GFP", "ImageNumber", "URL_GFP"))
  #MLF2_image <- MLF2_image[, c(2,1, 11, 37)]
  #MLF2_Area$URL_GFP <- MLF2_Area$URL_GFP
  MLF2_Area$Ratio_totalMLF2_vs_Cyto <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$AreaOccupied_AreaOccupied_Cyto)
  MLF2_Area$Avg_Size_Foci <- (MLF2_Area$AreaOccupied_AreaOccupied_MLF2_GFP / MLF2_Area$Count_MLF2_GFP)


  #Only use if there is an abberant dash between a random 2.... otherwise comment out
  MLF2_Area <- MLF2_Area %>%
  mutate_at(vars("URL_GFP"), funs(gsub("-2-", "", .)))

  #Extract plate, well and image number:
  
  #For 4TorKO cells
  # plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "-")
  # plate_Num_Temp <- sapply(plate_Num_Temp, "[[", 3)
  # plate_Num_Temp <- str_split(plate_Num_Temp, "_")
  # plate_Num <- sapply(plate_Num_Temp, "[[", 1)
  # Well_Num <- sapply(plate_Num_Temp, "[[", 2)
  # Image_Num <- sapply(plate_Num_Temp, "[[", 3)

  
#For WT Cells:
  plate_Num_Temp <- str_split(MLF2_Area$URL_GFP, "_")
  Well_Num <- lapply(plate_Num_Temp, function(x)  x[length(x) - 2])
  Well_Num <- unlist(Well_Num)
  Image_Num <- lapply(plate_Num_Temp, function(x) x[length(x) - 1]) #10
  Image_Num <- unlist(Image_Num)
  plate_Num_Temp <- lapply(plate_Num_Temp, function(x) x[length(x) - 3]) #8
  plate_Num_Temp <- str_split(plate_Num_Temp, "-")
  plate_Num <- sapply(plate_Num_Temp, "[[", 3)
  plate_Num <- unlist(plate_Num)
  MLF2_Area$plate_Num <- plate_Num
  MLF2_Area$Well_Num <- Well_Num
  MLF2_Area$Imagecopy_Num <- Image_Num

  df <- (merge(per_image_nuc, MLF2_Area))

  df$condition <- df$Well_Num
  df <- na.omit(df)

  df <- (merge(per_image_nuc, MLF2_Area))

  df$condition <- df$Well_Num
  df <- na.omit(df)

  #Groups all wells that share a single condition for aggregate statistics
  per_Well_Plate <- df %>%
  group_by(plate_Num, Well_Num, condition) %>%
    #Filters out top image in case of screen aberration
  filter(mean_Nuc_Foci < max(mean_Nuc_Foci)) %>%
  summarise(Nuclei_Number = mean(Nuclei_Number), mean_Nuc_Foci = mean(mean_Nuc_Foci), Ratio_totalMLF2_vs_Cyto = mean(Ratio_totalMLF2_vs_Cyto), Avg_Size_Foci = mean(Avg_Size_Foci))


  individual_Plates <- split(per_Well_Plate, f = per_Well_Plate$plate_Num)

} }) })

```

```{r}



    

```

```{r}
x <- rbind(c(2.31, 4.5, 3.6, 1.2, 3.0),
           c(4.4, 3.3, 4.1, 2.45, 6.2),
           c(1.1, 4.3, 5.2, 3.7, 5.33))

# Redirect output to null device
suppress_output <- capture.output({
  medpolish_resultss <- medpolish(x)
})

# Print median polish results
print(medpolish_resultss)

medpolish_results <- medpolish(x)
```

```{r}




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

